(define-syntax define-global!
  (syntax-rules ()
    ((_ 'name value) (define name value))))

(define gensym
  (let ((counter 14641))
    (lambda ()
      (let ((v (string->symbol (string-append "g" (number->string counter)))))
	(set! counter (+ counter 1))
	v))))

(define-global! 'map
  (lambda (f l)
    (if (null? l)
	'()
	(cons (f (car l))
	      (map f (cdr l))))))

(define-global! 'global-env
  (let ()
    (define (prim0 f) (lambda (arguments) (f)))
    (define (prim1 f) (lambda (arguments) (f (car arguments))))
    (define (prim2 f) (lambda (arguments) (f (car arguments) (cadr arguments))))
    (define (munge-entry entry) (cons (car entry) (cons (cadr entry) (box (caddr entry)))))
    (map munge-entry
	 `((let macro ,(lambda (x env exp)
			 (let ((names (map car (cadr x)))
			       (inits (map cadr (cadr x)))
			       (exps (cddr x)))
			   (exp `((lambda ,names ,@exps) ,@inits)))))
	   (cond macro ,(lambda (x env exp)
			  (exp (cond
				((null? (cdr x)) `(begin))
				((eq? (caadr x) 'else) `(begin ,@(cdadr x)))
				(else `(if ,(caadr x) (begin ,@(cdadr x)) (cond ,@(cddr x))))))))
	   (case macro ,(lambda (x env exp)
			  (let ((v (gensym)))
			    (exp `(let ((,v ,(cadr x)))
				    (cond
				     ,@(map (lambda (clause)
					      (cond
					       ((eq? (car clause) 'else) clause)
					       ((null? (cdar clause))
						`((eq? ,v ',(caar clause)) ,@(cdr clause)))
					       (else (12345678 'multi-case-not-supported clause))))
					    (cddr x))))))))
	   (and macro ,(lambda (x env exp)
			 (exp (cond
			       ((null? (cdr x)) `(begin))
			       ((null? (cddr x)) (cadr x))
			       (else `(if ,(cadr x) (and ,@(cddr x)) #f))))))
	   (,'quasiquote macro
			 ,(lambda (x env exp)
			    (define (qq exp depth)
			      (cond
			       ((not (pair? exp)) `(quote ,exp))
			       ((eq? (car exp) 'quasiquote)
				`(cons 'quasiquote (cons ,(qq (cadr exp) (+ depth 1)) '())))
			       ((eq? (car exp) 'unquote)
				(if (= depth 1)
				    (cadr exp)
				    `(cons ','unquote (cons ,(qq (cadr exp) (- depth 1)) '()))))
			       ((and (pair? (car exp))
				     (eq? (caar exp) 'unquote-splicing))
				(if (= depth 1)
				    `(append ,(cadar exp) ,(qq (cdr exp) depth))
				    `(cons ,(qq (car exp) (- depth 1))
					   ,(qq (cdr exp) depth))))
			       (else `(cons ,(qq (car exp) depth)
					    ,(qq (cdr exp) depth)))))
			    (exp (qq (cadr x) 1))))
	   (define-global! global ,(prim2
				    (lambda (name value)
				      ;; FIXME: should set if entry already exists!
				      (set! global-env (cons (munge-entry
							      (cons name
								    (cons 'global
									  (cons value '()))))
							     global-env)))))

	   (cdr global ,(prim1 cdr))
	   (cddr global ,(prim1 cddr))
	   (cddar global ,(prim1 cddar))
	   (cdar global ,(prim1 cdar))
	   (cdadr global ,(prim1 cdadr))
	   (car global ,(prim1 car))
	   (cadr global ,(prim1 cadr))
	   (caddr global ,(prim1 caddr))
	   (cadddr global ,(prim1 cadddr))
	   (cadar global ,(prim1 cadar))
	   (caar global ,(prim1 caar))
	   (caadr global ,(prim1 caadr))

	   (box global ,(prim1 box))
	   (unbox global ,(prim1 unbox))
	   (set-box! global ,(prim2 set-box!))
    
	   (append global ,(prim2 append))
	   (cons global ,(prim2 cons))
	   (eq? global ,(prim2 eq?))
	   (= global ,(prim2 =))
	   (not global ,(prim1 not))
	   (null? global ,(prim1 null?))
	   (pair? global ,(prim1 pair?))
	   (symbol? global ,(prim1 symbol?))

	   (gensym global ,(prim0 gensym))

	   ))))

(define-global! 'eval
  (let ()
    (define (error key val) (12345678 'magic-error-procedure key val))
    (define (undefined) 17)
    (define (env-null? env) (null? env))
    (define (env-name env) (caar env))
    (define (env-kind env) (cadar env))
    (define (env-value env) (unbox (cddar env)))
    (define (set-env-value! env value) (set-box! (cddar env) value))
    (define (env-next env) (cdr env))
    (define (make-env name kind value next) (cons (cons name (cons kind (box value))) next))
    (define (search-one-env env n k fk)
      (cond
       ((env-null? env) (fk))
       ((eq? (env-name env) n) (k (env-kind env) (env-value env) env))
       (else (search-one-env (env-next env) n k fk))))
    (define (search-env env n k fk)
      (search-one-env env n k (lambda () (search-one-env global-env n k fk))))
    (define (expand x env)
      (if (and (pair? x)
	       (symbol? (car x)))
	  (search-env env (car x)
		      (lambda (kind v cell) (if (eq? kind 'macro)
						(v x env (lambda (exp) (expand exp env)))
						x))
		      (lambda () x))
	  x))
    (define (make-recursive-env defs env)
      (if (null? defs)
	  env
	  (make-env (caar defs) 'local #f (make-recursive-env (cdr defs) env))))
    (define (e-recursive-definitions defs xs env)
      (let ((new-env (make-recursive-env defs env)))
	(define (fill-init defs pos)
	  (if (null? defs)
	      (e (cons 'begin xs) new-env)
	      (begin (set-env-value! pos (e (cdar defs) new-env))
		     (fill-init (cdr defs) (env-next pos)))))
	(fill-init defs new-env)))
    (define (e-body defs xs env)
      (if (null? xs)
	  (e-recursive-definitions defs xs env)
	  (let ((x (expand (car xs) env)))
	    (if (not (pair? x))
		(e-recursive-definitions defs (cons x (cdr xs)) env)
		(case (car x)
		  ((begin) (e-body defs (append (cdr x) (cdr xs)) env))
		  ((define) (if (pair? (cadr x))
				(e-body (cons (cons (caadr x)
						    `(lambda ,(cdadr x) ,@(cddr x)))
					      defs) (cdr xs) env)
				(e-body (cons (cons (cadr x) (caddr x)) defs) (cdr xs) env)))
		  (else (e-recursive-definitions defs (cons x (cdr xs)) env)))))))
    (define (e-args formals actuals env)
      (if (null? formals)
	  env
	  (make-env (car formals) 'local (car actuals) (e-args (cdr formals) (cdr actuals) env))))
    (define (e x env)
      (let ((x (expand x env)))
	(cond
	 ((symbol? x) (search-env env x
				  (lambda (kind v cell) (if (eq? kind 'macro)
							    (error 'macro-in-variable-position x)
							    v))
				  (lambda () (error 'unbound-variable x))))
	 ((not (pair? x)) x)
	 (else
	  (case (car x)
	    ((quote) (cadr x))
	    ((define) (error 'internal-definition-in-invalid-position x))
	    ((lambda) (lambda (actuals)
			(let ((new-env (e-args (cadr x) actuals env)))
			  (e-body '() (cddr x) new-env))))
	    ((begin) (cond ((null? (cdr x)) (undefined))
			   ((null? (cddr x)) (e (cadr x) env))
			   (else (begin (e (cadr x) env)
					(e (cons 'begin (cddr x)) env)))))
	    ((if) (if (e (cadr x) env)
		      (e (caddr x) env)
		      (e (cadddr x) env)))
	    ((set!) (search-env env (cadr x)
				(lambda (kind v cell) (if (eq? kind 'macro)
							  (error 'macro-in-variable-position x)
							  (set-env-value! cell (e (caddr x) env))))
				(lambda () (error 'unbound-variable x))))
	    (else
	     (let ((operands (map (lambda (a) (e a env)) (cdr x))))
	       (let ((operator (e (car x) env)))
		 (operator operands)))))))))
    (lambda (x)
      (e x '()))))

(define (syms x)
  (cond
   ((pair? x) (syms (car x)) (syms (cdr x)))
   ((null? x))
   (else (write x) (newline))))

(define (r)
  (display ">>> ")
  (let ((x (read)))
    (if (eof-object? x)
	'done
	(begin (write (eval x))
	       (newline)
	       (r)))))

(eval `(define-global! 'global-env ',global-env))
(r)
